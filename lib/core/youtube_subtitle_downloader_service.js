/**
 * Why: subtitle download has a multi-step pipeline (check availability -> download SRT -> convert to text);
 * centralizing this in a service lets both MCP tools and Electron IPC share the logic.
 */

import crypto from "crypto";
import fs from "fs";
import path from "path";
import { spawnSync } from "child_process";
import {
  insertNewTaskRecord,
  getCurrentIsoTimestamp,
  updateExistingTaskRecord,
} from "./download_task_persistent_json_store.js";
import {
  ensureYtDlpIsInstalledOrAutoInstall,
  buildSubtitleListCommandArguments,
  buildSubtitleDownloadCommandArguments,
  getYtDlpBinaryPath,
} from "./yt_dlp_command_argument_builder.js";

function generateUniqueTaskIdentifier() {
  if (crypto.randomUUID) return crypto.randomUUID();
  return `task_${Date.now()}_${Math.random().toString(16).slice(2, 10)}`;
}

function ensureDirectoryExistsRecursively(directoryPath) {
  fs.mkdirSync(directoryPath, { recursive: true });
}

/**
 * Why: SRT files contain timing codes and duplicate lines from auto-generated captions;
 * stripping them produces a clean readable transcript.
 */
export function convertSrtSubtitleContentToPlainText(srtContent) {
  const linesWithTimingAndNumbersRemoved = srtContent
    .replace(/^\d+\s*$/gm, "")
    .replace(/\d{2}:\d{2}:\d{2},\d{3}\s*-->\s*\d{2}:\d{2}:\d{2},\d{3}/g, "")
    .split("\n")
    .map((line) => line.trim())
    .filter(Boolean);

  // Why: auto-generated subtitles repeat lines across overlapping time ranges
  const alreadySeenLines = new Set();
  const deduplicatedLines = linesWithTimingAndNumbersRemoved.filter((line) => {
    if (alreadySeenLines.has(line)) return false;
    alreadySeenLines.add(line);
    return true;
  });

  return deduplicatedLines.join(" ").replace(/\s+/g, " ").trim();
}

function checkSubtitleAvailabilityForVideo(videoUrl, requestedLanguage) {
  const listSubsArgs = buildSubtitleListCommandArguments({ url: videoUrl });
  const listSubsResult = spawnSync(getYtDlpBinaryPath(), listSubsArgs, {
    encoding: "utf8",
    timeout: 30000,
  });

  const combinedOutput = (listSubsResult.stdout || "") + "\n" + (listSubsResult.stderr || "");
  const requestedLanguageCodes = requestedLanguage.split(",").map((lang) => lang.trim());

  const hasAutoGeneratedSubtitles = combinedOutput.includes("Available automatic captions");
  const hasManualSubtitles = combinedOutput.includes("Available subtitles");

  for (const languageCode of requestedLanguageCodes) {
    const languageLinePattern = new RegExp(`^${languageCode}\\s+`, "m");
    if (languageLinePattern.test(combinedOutput)) {
      return {
        available: true,
        language: languageCode,
        auto: hasAutoGeneratedSubtitles && !hasManualSubtitles,
      };
    }
  }

  if (hasAutoGeneratedSubtitles || hasManualSubtitles) {
    return {
      available: false,
      language: null,
      auto: false,
      reason: `Subtitles exist but not in requested language(s): ${requestedLanguage}. Check available languages with --list-subs.`,
    };
  }

  return {
    available: false,
    language: null,
    auto: false,
    reason: "No subtitles available for this video (neither manual nor auto-generated).",
  };
}

/**
 * Synchronously downloads subtitles and converts to transcript.
 * Returns a result object with paths and status.
 */
export function downloadSubtitlesAndGenerateTranscript({
  videoId,
  sourceUrl,
  outputDirectoryPath,
  requestedLanguage = "en-orig,en",
}) {
  ensureDirectoryExistsRecursively(outputDirectoryPath);
  ensureYtDlpIsInstalledOrAutoInstall();

  const taskId = generateUniqueTaskIdentifier();
  const createdAtTimestamp = getCurrentIsoTimestamp();

  const taskRecord = {
    id: taskId,
    type: "subtitle",
    video_id: videoId,
    source_url: sourceUrl,
    language: requestedLanguage,
    output_path: outputDirectoryPath,
    status: "checking",
    subtitle_path: null,
    transcript_path: null,
    error: null,
    created_at: createdAtTimestamp,
    updated_at: createdAtTimestamp,
    finished_at: null,
  };

  insertNewTaskRecord(taskRecord);

  const availabilityCheck = checkSubtitleAvailabilityForVideo(sourceUrl, requestedLanguage);

  if (!availabilityCheck.available) {
    updateExistingTaskRecord(taskId, {
      status: "no_subtitles",
      error: availabilityCheck.reason,
      finished_at: getCurrentIsoTimestamp(),
    });
    return {
      success: false,
      taskId,
      videoId,
      status: "no_subtitles",
      message: availabilityCheck.reason,
    };
  }

  updateExistingTaskRecord(taskId, {
    status: "downloading",
    language: availabilityCheck.language,
  });

  const outputFileTemplate = path.join(outputDirectoryPath, "%(title)s [%(id)s]");
  const subtitleDownloadArgs = buildSubtitleDownloadCommandArguments({
    url: sourceUrl,
    subLang: availabilityCheck.language,
    outputTemplate: outputFileTemplate,
  });

  const downloadResult = spawnSync(getYtDlpBinaryPath(), subtitleDownloadArgs, {
    encoding: "utf8",
    timeout: 60000,
  });

  if (downloadResult.status !== 0) {
    const errorMessage = (downloadResult.stderr || downloadResult.stdout || "Unknown error").trim();
    updateExistingTaskRecord(taskId, {
      status: "failed",
      error: errorMessage,
      finished_at: getCurrentIsoTimestamp(),
    });
    return { success: false, taskId, videoId, status: "failed", error: errorMessage };
  }

  // Why: yt-dlp prints the output path; if not found, fall back to scanning the directory
  const combinedOutput = (downloadResult.stdout || "") + "\n" + (downloadResult.stderr || "");
  const writtenFileMatch = combinedOutput.match(/Writing video subtitles to:\s*(.+\.srt)/);
  let srtFilePath = null;

  if (writtenFileMatch) {
    srtFilePath = writtenFileMatch[1].trim();
  } else {
    const directoryFiles = fs.readdirSync(outputDirectoryPath);
    const matchingSrtFiles = directoryFiles.filter(
      (fileName) => fileName.includes(videoId) && fileName.endsWith(".srt")
    );
    if (matchingSrtFiles.length > 0) {
      srtFilePath = path.join(outputDirectoryPath, matchingSrtFiles[matchingSrtFiles.length - 1]);
    }
  }

  if (!srtFilePath || !fs.existsSync(srtFilePath)) {
    updateExistingTaskRecord(taskId, {
      status: "failed",
      error: "SRT file not found after download.",
      finished_at: getCurrentIsoTimestamp(),
    });
    return { success: false, taskId, videoId, status: "failed", error: "SRT file not found after download." };
  }

  const srtContent = fs.readFileSync(srtFilePath, "utf-8");
  const plainTextTranscript = convertSrtSubtitleContentToPlainText(srtContent);
  const transcriptFilePath = srtFilePath.replace(/\.[^.]+\.srt$/, ".transcript.txt");

  fs.writeFileSync(transcriptFilePath, plainTextTranscript, "utf-8");

  updateExistingTaskRecord(taskId, {
    status: "completed",
    subtitle_path: srtFilePath,
    transcript_path: transcriptFilePath,
    finished_at: getCurrentIsoTimestamp(),
  });

  return {
    success: true,
    taskId,
    videoId,
    status: "completed",
    language: availabilityCheck.language,
    subtitlePath: srtFilePath,
    transcriptPath: transcriptFilePath,
    transcriptLength: plainTextTranscript.length,
    outputPath: outputDirectoryPath,
  };
}
